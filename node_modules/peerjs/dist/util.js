"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var defaultConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
var dataCount = 1;
var js_binarypack_1 = __importDefault(require("js-binarypack"));
var adapter_1 = require("./adapter");
exports.util = {
    noop: function () { },
    CLOUD_HOST: "0.peerjs.com",
    CLOUD_PORT: 443,
    chunkedBrowsers: { Chrome: 1 },
    chunkedMTU: 16300,
    logLevel: 0,
    setLogLevel: function (level) {
        var debugLevel = parseInt(level, 10);
        if (!isNaN(parseInt(level, 10))) {
            exports.util.logLevel = debugLevel;
        }
        else {
            exports.util.logLevel = level ? 3 : 0;
        }
        exports.util.log = exports.util.warn = exports.util.error = exports.util.noop;
        if (exports.util.logLevel > 0) {
            exports.util.error = exports.util._printWith("ERROR");
        }
        if (exports.util.logLevel > 1) {
            exports.util.warn = exports.util._printWith("WARNING");
        }
        if (exports.util.logLevel > 2) {
            exports.util.log = exports.util._print;
        }
    },
    setLogFunction: function (fn) {
        if (fn.constructor !== Function) {
            exports.util.warn("The log function you passed in is not a function. Defaulting to regular logs.");
        }
        else {
            exports.util._print = fn;
        }
    },
    _printWith: function (prefix) {
        return function () {
            var copy = Array.prototype.slice.call(arguments);
            copy.unshift(prefix);
            exports.util._print.apply(exports.util, copy);
        };
    },
    _print: function () {
        var err = false;
        var copy = Array.prototype.slice.call(arguments);
        copy.unshift("PeerJS: ");
        for (var i = 0, l = copy.length; i < l; i++) {
            if (copy[i] instanceof Error) {
                copy[i] = "(" + copy[i].name + ") " + copy[i].message;
                err = true;
            }
        }
        err ? console.error.apply(console, copy) : console.log.apply(console, copy);
    },
    defaultConfig: defaultConfig,
    browser: (function () {
        if (window.mozRTCPeerConnection) {
            return "Firefox";
        }
        else if (window.webkitRTCPeerConnection) {
            return "Chrome";
        }
        else if (window.RTCPeerConnection) {
            return "Supported";
        }
        else {
            return "Unsupported";
        }
    })(),
    supports: (function () {
        if (typeof adapter_1.RTCPeerConnection === "undefined") {
            return {};
        }
        var data = true;
        var audioVideo = true;
        var binaryBlob = false;
        var sctp = false;
        var onnegotiationneeded = !!window.webkitRTCPeerConnection;
        var pc, dc;
        try {
            pc = new adapter_1.RTCPeerConnection(defaultConfig, {
                optional: [{ RtpDataChannels: true }]
            });
        }
        catch (e) {
            data = false;
            audioVideo = false;
        }
        if (data) {
            try {
                dc = pc.createDataChannel("_PEERJSTEST");
            }
            catch (e) {
                data = false;
            }
        }
        if (data) {
            try {
                dc.binaryType = "blob";
                binaryBlob = true;
            }
            catch (e) { }
            var reliablePC = new adapter_1.RTCPeerConnection(defaultConfig, {});
            try {
                var reliableDC = reliablePC.createDataChannel("_PEERJSRELIABLETEST", {});
                sctp = reliableDC.reliable;
            }
            catch (e) { }
            reliablePC.close();
        }
        if (audioVideo) {
            audioVideo = !!pc.addStream;
        }
        if (pc) {
            pc.close();
        }
        return {
            audioVideo: audioVideo,
            data: data,
            binaryBlob: binaryBlob,
            binary: sctp,
            reliable: sctp,
            sctp: sctp,
            onnegotiationneeded: onnegotiationneeded
        };
    })(),
    validateId: function (id) {
        return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(id);
    },
    validateKey: function (key) {
        return !key || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.exec(key);
    },
    debug: false,
    inherits: function (ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    },
    extend: function (dest, source) {
        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                dest[key] = source[key];
            }
        }
        return dest;
    },
    pack: js_binarypack_1.default.pack,
    unpack: js_binarypack_1.default.unpack,
    log: function () {
        if (exports.util.debug) {
            var err = false;
            var copy = Array.prototype.slice.call(arguments);
            copy.unshift("PeerJS: ");
            for (var i = 0, l = copy.length; i < l; i++) {
                if (copy[i] instanceof Error) {
                    copy[i] = "(" + copy[i].name + ") " + copy[i].message;
                    err = true;
                }
            }
            err
                ? console.error.apply(console, copy)
                : console.log.apply(console, copy);
        }
    },
    setZeroTimeout: (function (global) {
        var timeouts = [];
        var messageName = "zero-timeout-message";
        function setZeroTimeoutPostMessage(fn) {
            timeouts.push(fn);
            global.postMessage(messageName, "*");
        }
        function handleMessage(event) {
            if (event.source == global && event.data == messageName) {
                if (event.stopPropagation) {
                    event.stopPropagation();
                }
                if (timeouts.length) {
                    timeouts.shift()();
                }
            }
        }
        if (global.addEventListener) {
            global.addEventListener("message", handleMessage, true);
        }
        else if (global.attachEvent) {
            global.attachEvent("onmessage", handleMessage);
        }
        return setZeroTimeoutPostMessage;
    })(window),
    chunk: function (bl) {
        var chunks = [];
        var size = bl.size;
        var index;
        var start = (index = 0);
        var total = Math.ceil(size / exports.util.chunkedMTU);
        while (start < size) {
            var end = Math.min(size, start + exports.util.chunkedMTU);
            var b = bl.slice(start, end);
            var chunk = {
                __peerData: dataCount,
                n: index,
                data: b,
                total: total
            };
            chunks.push(chunk);
            start = end;
            index += 1;
        }
        dataCount += 1;
        return chunks;
    },
    blobToArrayBuffer: function (blob, cb) {
        var fr = new FileReader();
        fr.onload = function (evt) {
            cb(evt.target.result);
        };
        fr.readAsArrayBuffer(blob);
    },
    blobToBinaryString: function (blob, cb) {
        var fr = new FileReader();
        fr.onload = function (evt) {
            cb(evt.target.result);
        };
        fr.readAsBinaryString(blob);
    },
    binaryStringToArrayBuffer: function (binary) {
        var byteArray = new Uint8Array(binary.length);
        for (var i = 0; i < binary.length; i++) {
            byteArray[i] = binary.charCodeAt(i) & 0xff;
        }
        return byteArray.buffer;
    },
    randomToken: function () {
        return Math.random()
            .toString(36)
            .substr(2);
    },
    isSecure: function () {
        return location.protocol === "https:";
    }
};
//# sourceMappingURL=util.js.map