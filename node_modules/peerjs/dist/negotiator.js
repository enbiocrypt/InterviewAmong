"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("./util");
var adapter_1 = require("./adapter");
exports.Negotiator = {
    pcs: {
        data: {},
        media: {}
    },
    queue: []
};
exports.Negotiator._idPrefix = "pc_";
exports.Negotiator.startConnection = function (connection, options) {
    var pc = exports.Negotiator._getPeerConnection(connection, options);
    connection.pc = connection.peerConnection = pc;
    if (connection.type === "media" && options._stream) {
        pc.addStream(options._stream);
    }
    if (options.originator) {
        if (connection.type === "data") {
            var config = {};
            if (!util_1.util.supports.sctp) {
                config = { reliable: options.reliable };
            }
            var dc = pc.createDataChannel(connection.label, config);
            connection.initialize(dc);
        }
        exports.Negotiator._makeOffer(connection);
    }
    else {
        exports.Negotiator.handleSDP("OFFER", connection, options.sdp);
    }
};
exports.Negotiator._getPeerConnection = function (connection, options) {
    if (!exports.Negotiator.pcs[connection.type]) {
        util_1.util.error(connection.type +
            " is not a valid connection type. Maybe you overrode the `type` property somewhere.");
    }
    if (!exports.Negotiator.pcs[connection.type][connection.peer]) {
        exports.Negotiator.pcs[connection.type][connection.peer] = {};
    }
    var peerConnections = exports.Negotiator.pcs[connection.type][connection.peer];
    var pc;
    if (options.pc) {
        pc = exports.Negotiator.pcs[connection.type][connection.peer][options.pc];
    }
    if (!pc || pc.signalingState !== "stable") {
        pc = exports.Negotiator._startPeerConnection(connection);
    }
    return pc;
};
exports.Negotiator._startPeerConnection = function (connection) {
    util_1.util.log("Creating RTCPeerConnection.");
    var id = exports.Negotiator._idPrefix + util_1.util.randomToken();
    var optional = {};
    if (connection.type === "data" && !util_1.util.supports.sctp) {
        optional = { optional: [{ RtpDataChannels: true }] };
    }
    else if (connection.type === "media") {
        optional = { optional: [{ DtlsSrtpKeyAgreement: true }] };
    }
    var pc = new adapter_1.RTCPeerConnection(connection.provider.options.config, optional);
    exports.Negotiator.pcs[connection.type][connection.peer][id] = pc;
    exports.Negotiator._setupListeners(connection, pc, id);
    return pc;
};
exports.Negotiator._setupListeners = function (connection, pc, pc_id) {
    var peerId = connection.peer;
    var connectionId = connection.id;
    var provider = connection.provider;
    util_1.util.log("Listening for ICE candidates.");
    pc.onicecandidate = function (evt) {
        if (evt.candidate) {
            util_1.util.log("Received ICE candidates for:", connection.peer);
            provider.socket.send({
                type: "CANDIDATE",
                payload: {
                    candidate: evt.candidate,
                    type: connection.type,
                    connectionId: connection.id
                },
                dst: peerId
            });
        }
    };
    pc.oniceconnectionstatechange = function () {
        switch (pc.iceConnectionState) {
            case "failed":
                util_1.util.log("iceConnectionState is disconnected, closing connections to " + peerId);
                connection.emit("error", new Error("Negotiation of connection to " + peerId + " failed."));
                connection.close();
                break;
            case "disconnected":
                util_1.util.log("iceConnectionState is disconnected, closing connections to " + peerId);
                connection.close();
                break;
            case "completed":
                pc.onicecandidate = util_1.util.noop;
                break;
        }
    };
    pc.onicechange = pc.oniceconnectionstatechange;
    util_1.util.log("Listening for data channel");
    pc.ondatachannel = function (evt) {
        util_1.util.log("Received data channel");
        var dc = evt.channel;
        var connection = provider.getConnection(peerId, connectionId);
        connection.initialize(dc);
    };
    util_1.util.log("Listening for remote stream");
    pc.ontrack = function (evt) {
        util_1.util.log("Received remote stream");
        var stream = evt.streams[0];
        var connection = provider.getConnection(peerId, connectionId);
        if (connection.type === "media") {
            connection.addStream(stream);
        }
    };
};
exports.Negotiator.cleanup = function (connection) {
    util_1.util.log("Cleaning up PeerConnection to " + connection.peer);
    var pc = connection.pc;
    if (!!pc &&
        ((pc.readyState && pc.readyState !== "closed") ||
            pc.signalingState !== "closed")) {
        pc.close();
        connection.pc = null;
    }
};
exports.Negotiator._makeOffer = function (connection) {
    var pc = connection.pc;
    pc.createOffer(function (offer) {
        util_1.util.log("Created offer.");
        if (!util_1.util.supports.sctp &&
            connection.type === "data" &&
            connection.reliable) {
            offer.sdp = Reliable.higherBandwidthSDP(offer.sdp);
        }
        pc.setLocalDescription(offer, function () {
            util_1.util.log("Set localDescription: offer", "for:", connection.peer);
            connection.provider.socket.send({
                type: "OFFER",
                payload: {
                    sdp: offer,
                    type: connection.type,
                    label: connection.label,
                    connectionId: connection.id,
                    reliable: connection.reliable,
                    serialization: connection.serialization,
                    metadata: connection.metadata,
                    browser: util_1.util.browser
                },
                dst: connection.peer
            });
        }, function (err) {
            if (err !=
                "OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer") {
                connection.provider.emitError("webrtc", err);
                util_1.util.log("Failed to setLocalDescription, ", err);
            }
        });
    }, function (err) {
        connection.provider.emitError("webrtc", err);
        util_1.util.log("Failed to createOffer, ", err);
    }, connection.options.constraints);
};
exports.Negotiator._makeAnswer = function (connection) {
    var pc = connection.pc;
    pc.createAnswer(function (answer) {
        util_1.util.log("Created answer.");
        if (!util_1.util.supports.sctp &&
            connection.type === "data" &&
            connection.reliable) {
            answer.sdp = Reliable.higherBandwidthSDP(answer.sdp);
        }
        pc.setLocalDescription(answer, function () {
            util_1.util.log("Set localDescription: answer", "for:", connection.peer);
            connection.provider.socket.send({
                type: "ANSWER",
                payload: {
                    sdp: answer,
                    type: connection.type,
                    connectionId: connection.id,
                    browser: util_1.util.browser
                },
                dst: connection.peer
            });
        }, function (err) {
            connection.provider.emitError("webrtc", err);
            util_1.util.log("Failed to setLocalDescription, ", err);
        });
    }, function (err) {
        connection.provider.emitError("webrtc", err);
        util_1.util.log("Failed to create answer, ", err);
    });
};
exports.Negotiator.handleSDP = function (type, connection, sdp) {
    sdp = new adapter_1.RTCSessionDescription(sdp);
    var pc = connection.pc;
    util_1.util.log("Setting remote description", sdp);
    pc.setRemoteDescription(sdp, function () {
        util_1.util.log("Set remoteDescription:", type, "for:", connection.peer);
        if (type === "OFFER") {
            exports.Negotiator._makeAnswer(connection);
        }
    }, function (err) {
        connection.provider.emitError("webrtc", err);
        util_1.util.log("Failed to setRemoteDescription, ", err);
    });
};
exports.Negotiator.handleCandidate = function (connection, ice) {
    var candidate = ice.candidate;
    var sdpMLineIndex = ice.sdpMLineIndex;
    connection.pc.addIceCandidate(new adapter_1.RTCIceCandidate({
        sdpMLineIndex: sdpMLineIndex,
        candidate: candidate
    }));
    util_1.util.log("Added ICE candidate for:", connection.peer);
};
//# sourceMappingURL=negotiator.js.map